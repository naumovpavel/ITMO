package utils;

import utils.validators.*;
import models.Model;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.*;
import java.util.function.Supplier;

import static java.util.Arrays.sort;

/**
 * Class that stores tree of the model
 */
public class ModelTree {
    private String name;
    private boolean mayNull = true;
    private boolean autoGenerated = false;
    private Class<?> type;
    public Supplier<? extends Model> constructor;
    private boolean primitive;
    private ArrayList<ModelTree> fields = new ArrayList<>();
    private boolean isEnum = false;
    private HashMap<String, ArrayList<Validatable>> validators = new HashMap<>();
    private HashMap<String, Enum<?>> enumConstants;

    /**
     * Creates an object containing the model tree
     * @param name name
     * @param type element type Class
     * @param <T> type of the element
     */
    public <T> ModelTree(String name, Class<T> type) {
        this.name = name;
        this.type = type;
        this.primitive = Converter.checkForPrimitive(type);
        if(type.isEnum()) {
            isEnum = true;
            //field.enumConstant = new ArrayList<>(Arrays.asList(field.type.getEnumConstants()));
            enumConstants = new HashMap<>();
            for(T x : type.getEnumConstants()) {
                enumConstants.put(x.toString(), (Enum<?>) x);
            }
        }
        if(!this.primitive) {
            try {
                Model obj = (Model) type.getConstructor().newInstance();
                this.constructor = obj.getConstructorReference();
                for(Field field : type.getDeclaredFields()) {
                    if(field.getName().equals("constraint")) {
                        continue;
                    }

                    Annotation[] annotations = field.getAnnotations();
                    validators.put(field.getName(), new ArrayList<>());
                    boolean autoGenerated = false;
                    boolean mayNull = true;

                    for(Annotation annotation : annotations) {
                        if(annotation instanceof AutoGenerated) {
                            autoGenerated = true;
                        }
                        if(annotation instanceof NotNull) {
                            mayNull = false;
                        }
                        ValidatableAnnotation validatableAnnotation = annotation.annotationType().getAnnotation(ValidatableAnnotation.class);
                        if(validatableAnnotation != null) {
                            Validatable validatable = validatableAnnotation.validator().getConstructor().newInstance();
                            if(annotation instanceof GraterThan) {
                                validatable = ((ValidatableWithArg)validatable).getInstance(((GraterThan)annotation).value());
                            } else if(annotation instanceof LessThan) {
                                validatable = ((ValidatableWithArg)validatable).getInstance(((LessThan)annotation).value());
                            } else {
                                validatable = validatable.getInstance();
                            }
                            validators.get(field.getName()).add(validatable);

                        }
                    }

                    this.fields.add(new ModelTree(field.getName(), field.getType()));
                    this.fields.get(this.fields.size() - 1).autoGenerated = autoGenerated;
                    this.fields.get(this.fields.size() - 1).mayNull = mayNull;
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        fields.sort(Comparator.comparing((x) -> x.name));
    }

    /**
     * Creates an object containing the model tree and set name to class name of the type
     * @param type element type Class
     * @param <T> type of the element
     */
    public <T> ModelTree(Class<T> type) {
        this(type.getName(), type);
    }

    /**
     * Returns nodes name
     * @return name
     */
    public String getName() {
        return name;
    }

    /**
     * Returns true if node can be null
     * @return isMayNull
     */
    public boolean isMayNull() {
        return mayNull;
    }

    /**
     * Returns true if node is auto generating
     * @return isAutoGenerated
     */
    public boolean isAutoGenerated() {
        return autoGenerated;
    }

    /**
     * Returns type of node
     * @return type
     */
    public Class<?> getType() {
        return type;
    }

    /**
     * Returns reference to model constructor
     * @return reference to model constructor
     */
    public Supplier<? extends Model> getConstructor() {
        return constructor;
    }

    /**
     * Returns true if node type is primitive
     * @return isPrimitive
     */
    public boolean isPrimitive() {
        return primitive;
    }

    /**
     * Returns models fields
     * @return ArrayList of fields(field also model tree)
     */
    public ArrayList<ModelTree> getFields() {
        return fields;
    }

    /**
     * Returns true if node type is Enum
     * @return isEnum
     */
    public boolean isEnum() {
        return isEnum;
    }

    /**
     * Returns validators for models fields
     * @return HashMap of validators
     * @see Validatable
     */
    public HashMap<String, ArrayList<Validatable>> getValidators() {
        return validators;
    }

    /**
     * Returns enum constants if node is Enum
     * @return HashMap of enum constants
     */
    public HashMap<String, Enum<?>> getEnumConstants() {
        return enumConstants;
    }

    /**
     * Prints model tree
     * @param tree tree
     * @param tab indent
     */
    public static void print(ModelTree tree, String tab) {
        System.out.println(tab + tree.name + " " + tree.mayNull);
        if(!tree.primitive) {
            for(ModelTree x : tree.fields) {
                ModelTree.print(x, tab + "  ");
            }
        }
    }
}
